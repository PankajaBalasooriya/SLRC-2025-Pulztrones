/*
 * TCS3472.c
 *
 *  Created on: Apr 1, 2025
 *      Author: PANKAJA
 */


#include "TCS3472.h"
#include <string.h>
#include <stdio.h>

/* External UART handle - should be defined in your main.c */
extern UART_HandleTypeDef huart3;

/* I2C MUX handle */
I2C_MUX_HandleTypeDef color_mux = {
    .hi2c = &hi2c1,   // Assign I2C1 handle
    .rst_port = NULL,  // No reset pin used (set if needed)
    .rst_pin = 0,      // No reset pin used
    .addr_offset = 0   // Change if the address is modified by A0-A2 pins
};

/* Color calibration thresholds */
LineColorConfig line_color_config = {
    .black_threshold = 1000,
    .white_threshold = 5000,
    .green_ratio_min = 110,
    .green_ratio_max = 150,
    .is_calibrated = 0
};

/* Object color calibration thresholds */
ObjectColorConfig object_color_config = {
    .white_min_c = 5000,
    .red_min_ratio_r_to_g = 150,
    .red_min_ratio_r_to_b = 150,
    .blue_min_ratio_b_to_r = 150,
    .blue_min_ratio_b_to_g = 120,
    .yellow_min_ratio_r_to_b = 150,
    .yellow_min_ratio_g_to_b = 150,
    .yellow_r_g_diff_percent = 80
};

/* Initialize the TCS3472 system */
uint8_t TCS3472_Init(I2C_HandleTypeDef *hi2c, i2c_mux *mux) {
    if (hi2c == NULL || mux == NULL) {
        return HAL_ERROR;
    }

    color_mux.hi2c = hi2c;
    memcpy(&color_mux, mux, sizeof(i2c_mux));

    return HAL_OK;
}

/* Initialize a specific TCS3472 sensor */
uint8_t TCS3472_InitSensor(uint8_t channel) {
    TCS3472_SelectSensor(channel);

    /* Check if sensor is responding */
    uint8_t id = TCS3472_GetID(channel);
    if (id != 0x44 && id != 0x4D) {
        return HAL_ERROR;  // Sensor not detected
    }

    /* Power ON the device */
    TCS3472_Enable(channel);

    /* Set integration time (1 = 2.4ms, 255 = 614.4ms) */
    TCS3472_SetIntegrationTime(channel, 0x00);  // Minimum integration time

    /* Set gain (0 = 1x, 1 = 4x, 2 = 16x, 3 = 60x) */
    TCS3472_SetGain(channel, 3);  // 60x gain

    /* Wait for a moment for the sensor to stabilize */
    HAL_Delay(50);

    return HAL_OK;
}

/* Initialize both sensors */
uint8_t TCS3472_InitAll(void) {
    uint8_t status = HAL_OK;
    char msg[100];

    /* Initialize line sensor */
    if (TCS3472_InitSensor(MUX_CHANNEL_LINE_SENSOR) != HAL_OK) {
        sprintf(msg, "Line sensor (TCS3472) initialization failed!\r\n");
        HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
        status = HAL_ERROR;
    } else {
        sprintf(msg, "Line sensor (TCS3472) initialized successfully!\r\n");
        HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
    }

    /* Initialize object sensor */
    if (TCS3472_InitSensor(MUX_CHANNEL_OBJECT_SENSOR) != HAL_OK) {
        sprintf(msg, "Object sensor (TCS3472) initialization failed!\r\n");
        HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
        status = HAL_ERROR;
    } else {
        sprintf(msg, "Object sensor (TCS3472) initialized successfully!\r\n");
        HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
    }

    return status;
}

/* Get device ID */
uint8_t TCS3472_GetID(uint8_t channel) {
    return TCS3472_Read8(channel, TCS3472_REG_ID);
}

/* Enable the device */
void TCS3472_Enable(uint8_t channel) {
    /* Power ON */
    TCS3472_Write(channel, TCS3472_REG_ENABLE, TCS3472_ENABLE_PON);
    HAL_Delay(3);  // Wait 2.4ms for power-up

    /* Enable RGBC sensor */
    TCS3472_Write(channel, TCS3472_REG_ENABLE, TCS3472_ENABLE_PON | TCS3472_ENABLE_AEN);
}

/* Disable the device */
void TCS3472_Disable(uint8_t channel) {
    /* Get current value */
    uint8_t val = TCS3472_Read8(channel, TCS3472_REG_ENABLE);

    /* Turn off AEN and PON */
    TCS3472_Write(channel, TCS3472_REG_ENABLE, val & ~(TCS3472_ENABLE_PON | TCS3472_ENABLE_AEN));
}

/* Set integration time */
void TCS3472_SetIntegrationTime(uint8_t channel, uint8_t time) {
    TCS3472_Write(channel, TCS3472_REG_ATIME, time);
}

/* Set gain */
void TCS3472_SetGain(uint8_t channel, uint8_t gain) {
    if (gain > 3) gain = 3;
    TCS3472_Write(channel, TCS3472_REG_CONTROL, gain);
}

/* Get RGB and Clear values */
void TCS3472_GetRGBC(uint8_t channel, uint16_t *r, uint16_t *g, uint16_t *b, uint16_t *c) {
    /* Wait for data to be valid */
    while (!(TCS3472_Read8(channel, TCS3472_REG_STATUS) & 0x01));

    /* Read all values */
    *c = TCS3472_Read16(channel, TCS3472_REG_CDATAL);
    *r = TCS3472_Read16(channel, TCS3472_REG_RDATAL);
    *g = TCS3472_Read16(channel, TCS3472_REG_GDATAL);
    *b = TCS3472_Read16(channel, TCS3472_REG_BDATAL);
}

/* Detect line color based on RGB values */
uint8_t TCS3472_DetectLineColor(uint16_t r, uint16_t g, uint16_t b, uint16_t c) {
    if (c < line_color_config.black_threshold) {
        return COLOR_BLACK;
    }

    if (c > line_color_config.white_threshold) {
        uint16_t g_to_r_ratio = 0;
        if (r > 10) {
            g_to_r_ratio = (g * 100) / r;
        }

        if (g_to_r_ratio >= line_color_config.green_ratio_min &&
            g_to_r_ratio <= line_color_config.green_ratio_max &&
            g > r && g > b) {
            return COLOR_GREEN;
        }

        if (r > 500 && g > 500 && b > 500 &&
            (r * 100) / c > 20 && (g * 100) / c > 20 && (b * 100) / c > 20) {
            return COLOR_WHITE;
        }
    }

    return COLOR_UNKNOWN;
}

/* Detect object color based on RGB values */
uint8_t TCS3472_DetectObjectColor(uint16_t r, uint16_t g, uint16_t b, uint16_t c) {
    if (r < 10) r = 10;
    if (g < 10) g = 10;
    if (b < 10) b = 10;

    uint16_t r_to_g_ratio = (r * 100) / g;
    uint16_t r_to_b_ratio = (r * 100) / b;
    uint16_t g_to_b_ratio = (g * 100) / b;
    uint16_t b_to_r_ratio = (b * 100) / r;
    uint16_t b_to_g_ratio = (b * 100) / g;

    uint16_t r_g_similarity;
    if (r > g) {
        r_g_similarity = (g * 100) / r;
    } else {
        r_g_similarity = (r * 100) / g;
    }

    /* White detection */
    if (c > object_color_config.white_min_c &&
        r > 1000 && g > 1000 && b > 1000 &&
        r_g_similarity > 80 &&
        (b * 100) / ((r + g) / 2) > 80) {
        return COLOR_WHITE;
    }

    /* Red detection */
    if (r_to_g_ratio > object_color_config.red_min_ratio_r_to_g &&
        r_to_b_ratio > object_color_config.red_min_ratio_r_to_b) {
        return COLOR_RED;
    }

    /* Blue detection */
    if (b_to_r_ratio > object_color_config.blue_min_ratio_b_to_r &&
        b_to_g_ratio > object_color_config.blue_min_ratio_b_to_g) {
        return COLOR_BLUE;
    }

    /* Yellow-Orange detection */
    if (r_to_b_ratio > object_color_config.yellow_min_ratio_r_to_b &&
        g_to_b_ratio > object_color_config.yellow_min_ratio_g_to_b &&
        r_g_similarity > object_color_config.yellow_r_g_diff_percent) {
        return COLOR_YELLOW_ORANGE;
    }

    return COLOR_UNKNOWN;
}

/* Calibration functions (implementation similar to your original code) */
void TCS3472_CalibrateColors(void) {
    /* Implementation remains the same as your original */
    /* ... */
}

void TCS3472_CalibrateObjectColors(void) {
    /* Implementation remains the same as your original */
    /* ... */
}

/* Helper functions */
void TCS3472_SelectSensor(uint8_t channel) {
    i2c_mux_select(&color_mux, channel);
    HAL_Delay(2); // Small delay for mux to stabilize
}

void TCS3472_Write(uint8_t channel, uint8_t reg, uint8_t value) {
    uint8_t data[2];
    data[0] = TCS3472_COMMAND_BIT | reg;
    data[1] = value;

    TCS3472_SelectSensor(channel);
    HAL_I2C_Master_Transmit(color_mux.hi2c, TCS3472_ADDR, data, 2, 100);
}

uint8_t TCS3472_Read8(uint8_t channel, uint8_t reg) {
    uint8_t cmd = TCS3472_COMMAND_BIT | reg;
    uint8_t value;

    TCS3472_SelectSensor(channel);
    HAL_I2C_Master_Transmit(color_mux.hi2c, TCS3472_ADDR, &cmd, 1, 100);
    HAL_I2C_Master_Receive(color_mux.hi2c, TCS3472_ADDR, &value, 1, 100);

    return value;
}

uint16_t TCS3472_Read16(uint8_t channel, uint8_t reg) {
    uint8_t cmd = TCS3472_COMMAND_BIT | reg;
    uint8_t data[2];

    TCS3472_SelectSensor(channel);
    HAL_I2C_Master_Transmit(color_mux.hi2c, TCS3472_ADDR, &cmd, 1, 100);
    HAL_I2C_Master_Receive(color_mux.hi2c, TCS3472_ADDR, data, 2, 100);

    return (data[1] << 8) | data[0];
}
