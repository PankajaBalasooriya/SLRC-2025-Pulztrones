#include "tasks.h"
#include "sensors.h"
#include "robot.h"
#include "buzzer.h"
#include "ballstorage.h"
#include "display.h"
#include "systick.h"


// Initialize task status globally
extern volatile uint32_t okbtncount;
extern volatile uint32_t prevokbtncount;

extern volatile uint32_t nextbtncount;
extern volatile uint32_t prevnextbtncount;

// Function to update task status
volatile uint32_t delay_end_time = 0;

uint8_t ball_pos = 0;

extern volatile TaskType currentTask;

// Start a non-blocking delay (delay in milliseconds)
void NonBlockingDelay(uint32_t delay_ms)
{
    delay_end_time = HAL_GetTick() + delay_ms;  // Set the target time
}

// Check if the delay is complete
uint8_t IsDelayComplete(void)
{
    return (HAL_GetTick() >= delay_end_time);  // Return true if the current time has passed the target time
}


//---------Start 0f Plantation Task (Collect and identify potatoes)--------------------
Color Newlinecolor = WHITE;
Color Nextlinecolor = WHITE;
uint8_t prev_potato_row = 4;

Color linecolor = WHITE;

Color ballcolor;

int potato_row[5] = {-1, -1, -1, -1, -1};

void executePlantationTask(void) {
	//StartLineColorDetection();
	Buzzer_Toggle(100);
	HAL_Delay(2000);
	Buzzer_Toggle(300);
	Robot_MoveForwardUntillLine();
	Robot_TurnLeft90Inplace();
	moveToCenterofNextCell();

	//Start the task
	for(uint8_t row = 0; row < 3; row ++){
		for(uint8_t column = 0; column < 5; column ++){


			if(potato_row[column] != -1){
				continue;
			}

			linecolor = GetLineColor(column, row);

			if(linecolor == GREEN){
				potato_row[column] = row;

				//Dummy function
				ballcolor = picktheBall(column, row);

				//Todo: store the ball based on color


			}
			if(column != 4){
				moveToCenterofNextCell();
			}
			else{
				Robot_MoveReverseGivenDistance(50);
				Robot_TurnRight90Inplace();
				Robot_TurnRight90Inplace();
				while(1){

				}
			}

		}
	}






//	//Start the task
//	for(uint8_t column = 0; column < 5; column ++){
//		for(uint8_t row = 0; row < 4; row ++){
//				if(row == 0){
//					moveToCenterofCellinZeroRow();
//
//					//Todo: Get line color
//					//Dummy function
//					line_color = GetLineColor(column, row);
//
//					if(linecolor == GREEN && prev_potato_row != row){
//						prev_potato_row = row;
//
//						//Dummy function
//						ballcolor = picktheBall(column, row);
//
//						//Todo: store the ball based on color
//
//						moveToCenterofNextColumnfromFirstRow();
//						break;
//
//					}
//
//				}
//				else if(row == 1){
//					moveToCenterofNextCell();
//					line_color = GetLineColor(column, row);
//
//
//					if(linecolor == GREEN && prev_potato_row != row){
//						prev_potato_row = row;
//
//						//Dummy function
//						ballcolor = picktheBall(column, row);
//
//						//Todo: store the ball based on color
//
//						moveToCenterofNextColumnfromFirstRow();
//						break;
//
//					}
//
//				}else if(row == 2){
//					//linecolor = RPI_GetLineColor(column, row);
//					//Newlinecolor = RPI_GetLineColor();
//					moveToCenterofNextCell();
//
//					line_color = GetLineColor(column, row);
//					prev_potato_row = row;
//
//					//Dummy function
//					ballcolor = picktheBall(column, row);
//
//					//Todo: store the ball based on color
//
//					moveToCenterofNextColumnfromFirstRow();
//
//
//
//		}
//
//	}
//
//  }
}

void moveToCenterofNextCell(){
	Robot_LineFollowUntillJunctionAndNotStop();
	Robot_FollowLineGivenDistance(DISTACE_TO_CENTER_OF_CELL);
}

void moveToCenterofNextCellandNotStop(){
	Robot_LineFollowUntillJunctionAndNotStop();
	Robot_FollowLineGivenDistanceandNotStop(DISTACE_TO_CENTER_OF_CELL);
}

void moveToCenterofCellinZeroRow(){
	Robot_LineFollowUntillJunction();
	Robot_TurnRight90Inplace();
	Robot_FollowLineGivenDistance(DISTACE_TO_CENTER_OF_CELL);
	HAL_Delay(MOTION_DELAY);
}

void moveToCenterofNextColumnfromFirstRow(){
	moveToCenterofCellinZeroRow();
}

void moveToCenterofNextColumnfromSecondRow(){
	//moveToCenterofNextCell();
	moveToCenterofNextCellandNotStop();
	//HAL_Delay(MOTION_DELAY);
	moveToCenterofNextColumnfromFirstRow();
}

void moveToCenterofNextColumnfromThiredRow(){
	//moveToCenterofNextCell();
	moveToCenterofNextCellandNotStop();
	//HAL_Delay(MOTION_DELAY);
	moveToCenterofNextColumnfromSecondRow();
}

Color picktheBall(uint8_t column, uint8_t row){

	if(row == 1){
		Robot_TurnLeft90Inplace();
	}
	else{
		Robot_TurnRight90Inplace();
	}



	//ToDo: Get ball color
	ballcolor = GetBallColor(column, row);

	//ToDo: Pick The ball
	Buzzer_Toggle(1000);

	if(row == 1){
		Robot_TurnRight90Inplace();
	}
	else{
		Robot_TurnLeft90Inplace();
	}


	//Robot_TurnLeft90Inplace();

	return ballcolor;
}


//---------end 0f Plantation Task (Collect and identify potatoes)---------------------

//================================================================================================

//---------Start 0f colorBox Task (Drop the potatoes to the identified boxed)--------------------

void executePotatoSeperationTask(void){
	Robot_LineFollowUntillJunction();
	HAL_Delay(MOTION_DELAY);


	// If line following initially

	Robot_TurnRight90Inplace();

	Robot_FollowLineGivenDistance(DISTACE_TO_CENTER_OF_CELL);

	Robot_TurnLeft90Inplace();

	Robot_MoveForwardUntillLine();

	//Drop the baalls

	//retrieve_ball(WHITE_BALL);
	Buzzer_Toggle(300);

	HAL_Delay(2000);

	Robot_MoveReverseGivenDistance(120);

	Robot_TurnRight90Inplace();

	Robot_MoveForwardGivenDistance(2 * DISTACE_TO_CENTER_OF_CELL);

	Robot_TurnLeft90Inplace();

	Robot_MoveForwardUntillLine();

	//retrieve_ball(YELLOW_BALL);
	Buzzer_Toggle(300);


}


//---------end 0f colorBox Task (Collect and identify potatoes)---------------------










// -----------------------------Task manager function---------------------------------
void selectTask(){
	display_clear();
	display_headding("Tasks");

	while(1){
		if(prevnextbtncount != nextbtncount){
			display_big_number(nextbtncount);
			switch(nextbtncount){
			case 1:
				display_message("Plantation Task", 12, 45);
				currentTask = TASK_PLANTATION;
				break;
			case 2:
				display_message("Muddy Road", 12, 45);
				currentTask = TASK_MUDDY_ROAD;
				break;
			default:
				break;
			}
			prevnextbtncount = nextbtncount;
		}





		if(prevokbtncount != okbtncount){
			prevokbtncount = okbtncount;
			break;
		}

	}
	display_headding("Start Task");
	while(okbtncount == prevokbtncount);
	Reset_buttons();

	runCurrentTask();
}



void runCurrentTask() {
	EnableSysTickFunction();
	Buzzer_Toggle(500);

    switch (currentTask) {
        case TASK_PLANTATION:
            executePlantationTask();
            break;
        case TASK_SORTING_POTATOS:
        	executePotatoSeperationTask();
        default:
            break;
    }

    // Print final status after execution

}

