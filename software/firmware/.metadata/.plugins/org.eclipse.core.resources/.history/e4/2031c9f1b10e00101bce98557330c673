/*
 * TCS3472.c
 *
 *  Created on: Apr 1, 2025
 *      Author: PANKAJA
 */


/*
 * TCS3472 Color Sensor Driver for STM32F446RE
 * Implementation file for the TCS3472 color sensor driver
 */

#include "TCS3472.h"
#include <stdio.h>
#include <string.h>

/* Private function prototypes */
static void TCS3472_Write(TCS3472_t *sensor, uint8_t reg, uint8_t value);
static uint8_t TCS3472_Read8(TCS3472_t *sensor, uint8_t reg);
static uint16_t TCS3472_Read16(TCS3472_t *sensor, uint8_t reg);

/* Initialize TCS3472 sensor */
uint8_t TCS3472_Init(TCS3472_t *sensor)
{
    /* Check if sensor is responding */
    uint8_t id = TCS3472_GetID(sensor);
    if (id != 0x44 && id != 0x4D) {
        return HAL_ERROR;  // Sensor not detected
    }

    /* Power ON the device */
    TCS3472_Enable(sensor);

    /* Set integration time (1 = 2.4ms, 255 = 614.4ms) */
    TCS3472_SetIntegrationTime(sensor, 0x00);  // Minimum integration time (2.4ms) for fast readings

    /* Set gain (0 = 1x, 1 = 4x, 2 = 16x, 3 = 60x) */
    TCS3472_SetGain(sensor, 3);  // 60x gain for better contrast in color detection

    /* Wait for a moment for the sensor to stabilize */
    HAL_Delay(50);

    return HAL_OK;
}

/* Get device ID */
uint8_t TCS3472_GetID(TCS3472_t *sensor)
{
    return TCS3472_Read8(sensor, TCS3472_REG_ID);
}

/* Enable the device */
void TCS3472_Enable(TCS3472_t *sensor)
{
    /* Power ON */
    TCS3472_Write(sensor, TCS3472_REG_ENABLE, TCS3472_ENABLE_PON);
    HAL_Delay(3);  // Wait 2.4ms for power-up

    /* Enable RGBC sensor */
    TCS3472_Write(sensor, TCS3472_REG_ENABLE, TCS3472_ENABLE_PON | TCS3472_ENABLE_AEN);
}

/* Disable the device */
void TCS3472_Disable(TCS3472_t *sensor)
{
    /* Get current value */
    uint8_t val = TCS3472_Read8(sensor, TCS3472_REG_ENABLE);

    /* Turn off AEN and PON */
    TCS3472_Write(sensor, TCS3472_REG_ENABLE, val & ~(TCS3472_ENABLE_PON | TCS3472_ENABLE_AEN));
}

/* Set integration time */
void TCS3472_SetIntegrationTime(TCS3472_t *sensor, uint8_t time)
{
    /* Write integration time to the register */
    TCS3472_Write(sensor, TCS3472_REG_ATIME, time);
}

/* Set gain */
void TCS3472_SetGain(TCS3472_t *sensor, uint8_t gain)
{
    /* Check if gain is valid (0-3) */
    if (gain > 3) gain = 3;

    /* Write gain to the register */
    TCS3472_Write(sensor, TCS3472_REG_CONTROL, gain);
}

/* Get RGB and Clear values */
void TCS3472_GetRGBC(TCS3472_t *sensor, uint16_t *r, uint16_t *g, uint16_t *b, uint16_t *c)
{
    /* Wait for data to be valid */
    while (!(TCS3472_Read8(sensor, TCS3472_REG_STATUS) & 0x01));

    /* Read all values */
    *c = TCS3472_Read16(sensor, TCS3472_REG_CDATAL);
    *r = TCS3472_Read16(sensor, TCS3472_REG_RDATAL);
    *g = TCS3472_Read16(sensor, TCS3472_REG_GDATAL);
    *b = TCS3472_Read16(sensor, TCS3472_REG_BDATAL);
}

/* Detect line color based on RGB values */
uint8_t TCS3472_DetectLineColor(TCS3472_t *sensor, uint16_t r, uint16_t g, uint16_t b, uint16_t c)
{
    LineColorConfig_t *config = &sensor->config.line;

    /* If not calibrated, use default values */
    if (!config->is_calibrated) {
        config->black_threshold = 1000;
        config->white_threshold = 5000;
        config->green_ratio_min = 110;
        config->green_ratio_max = 150;
    }

    /* If overall brightness is very low, it's black (background) */
    if (c < config->black_threshold) {
        return COLOR_BLACK;
    }

    /* If overall brightness is high, check if it's white or green */
    if (c > config->white_threshold) {
        /* Calculate green-to-red ratio (multiplied by 100 to avoid floating point) */
        uint16_t g_to_r_ratio = 0;

        /* Avoid division by zero */
        if (r > 10) {
            g_to_r_ratio = (g * 100) / r;
        }

        /* If green is significantly higher than red, it's green */
        if (g_to_r_ratio >= config->green_ratio_min &&
            g_to_r_ratio <= config->green_ratio_max &&
            g > r && g > b) {
            return COLOR_GREEN;
        }

        /* If all colors are relatively balanced and bright, it's white */
        if (r > 500 && g > 500 && b > 500 &&
            (r * 100) / c > 20 && (g * 100) / c > 20 && (b * 100) / c > 20) {
            return COLOR_WHITE;
        }
    }

    /* If we can't identify the color */
    return COLOR_UNKNOWN;
}

/* Detect object color based on RGB values */
uint8_t TCS3472_DetectObjectColor(TCS3472_t *sensor, uint16_t r, uint16_t g, uint16_t b, uint16_t c)
{
    ObjectColorConfig_t *config = &sensor->config.object;

    /* If not calibrated, use default values */
    if (!config->is_calibrated) {
        config->white_threshold = 5000;
        config->red_ratio_min = 150;
        config->red_ratio_max = 300;
        config->blue_ratio_min = 150;
        config->blue_ratio_max = 300;
        config->orange_yellow_ratio_min = 110;
        config->orange_yellow_ratio_max = 140;
    }

    /* If overall brightness is too low, can't detect */
    if (c < 1000) {
        return OBJ_COLOR_UNKNOWN;
    }

    /* Calculate color ratios (multiplied by 100 to avoid floating point) */
    uint16_t r_to_g_ratio = (r > 10 && g > 10) ? (r * 100) / g : 0;
    uint16_t b_to_g_ratio = (b > 10 && g > 10) ? (b * 100) / g : 0;
    uint16_t r_to_b_ratio = (r > 10 && b > 10) ? (r * 100) / b : 0;

    /* White detection - all colors relatively balanced and bright */
    if (c > config->white_threshold &&
        r > 1000 && g > 1000 && b > 1000 &&
        r_to_g_ratio >= 70 && r_to_g_ratio <= 130 &&
        b_to_g_ratio >= 70 && b_to_g_ratio <= 130) {
        return OBJ_COLOR_WHITE;
    }

    /* Red detection - red significantly higher than others */
    if (r > g && r > b &&
        r_to_g_ratio >= config->red_ratio_min &&
        r_to_g_ratio <= config->red_ratio_max &&
        r_to_b_ratio >= 150) {
        return OBJ_COLOR_RED;
    }

    /* Blue detection - blue significantly higher than others */
    if (b > r && b > g &&
        b_to_g_ratio >= config->blue_ratio_min &&
        b_to_g_ratio <= config->blue_ratio_max) {
        return OBJ_COLOR_BLUE;
    }

    /* Orange-Yellow detection - red higher than blue, but not as extreme as pure red */
    if (r > b && r > g &&
        r_to_g_ratio >= config->orange_yellow_ratio_min &&
        r_to_g_ratio <= config->orange_yellow_ratio_max &&
        r_to_b_ratio >= 150) {
        return OBJ_COLOR_ORANGE_YELLOW;
    }

    /* If we can't identify the color */
    return OBJ_COLOR_UNKNOWN;
}

/* Calibration function for line sensor */
void TCS3472_CalibrateLineColors(TCS3472_t *sensor, UART_HandleTypeDef *huart)
{
    char buffer[100];
    uint16_t r, g, b, c;
    uint16_t black_readings[5] = {0};
    uint16_t white_readings[5] = {0};
    uint16_t green_readings_r[5] = {0};
    uint16_t green_readings_g[5] = {0};
    LineColorConfig_t *config = &sensor->config.line;

    /* Send calibration instructions */
    sprintf(buffer, "Starting LINE sensor calibration sequence...\r\n");
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

    /* 1. Calibrate BLACK background */
    sprintf(buffer, "Place LINE sensor over BLACK surface and press USER button (PA0)...\r\n");
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

    /* Wait for button press */
    //while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET);
    HAL_Delay(5000); // Debounce

    /* Take 5 readings of black background */
    for (int i = 0; i < 5; i++) {
        TCS3472_GetRGBC(sensor, &r, &g, &b, &c);
        black_readings[i] = c;
        HAL_Delay(50);
    }

    /* Calculate average */
    uint32_t black_sum = 0;
    for (int i = 0; i < 5; i++) {
        black_sum += black_readings[i];
    }
    config->black_threshold = (black_sum / 5) * 1.5; // 50% margin

    sprintf(buffer, "BLACK calibrated: threshold = %d\r\n", config->black_threshold);
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
    HAL_Delay(1000);

    /* 2. Calibrate WHITE line */
    sprintf(buffer, "Place LINE sensor over WHITE line and press USER button (PA0)...\r\n");
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

    /* Wait for button press */
    //while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET);
    HAL_Delay(5000); // Debounce

    /* Take 5 readings of white line */
    for (int i = 0; i < 5; i++) {
        TCS3472_GetRGBC(sensor, &r, &g, &b, &c);
        white_readings[i] = c;
        HAL_Delay(50);
    }

    /* Calculate average */
    uint32_t white_sum = 0;
    for (int i = 0; i < 5; i++) {
        white_sum += white_readings[i];
    }
    config->white_threshold = (white_sum / 5) * 0.8; // 20% margin

    sprintf(buffer, "WHITE calibrated: threshold = %d\r\n", config->white_threshold);
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
    HAL_Delay(1000);

    /* 3. Calibrate GREEN line */
    sprintf(buffer, "Place LINE sensor over GREEN line and press USER button (PA0)...\r\n");
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

    /* Wait for button press */
    //while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET);
    HAL_Delay(5000); // Debounce

    /* Take 5 readings of green line */
    for (int i = 0; i < 5; i++) {
        TCS3472_GetRGBC(sensor, &r, &g, &b, &c);
        green_readings_r[i] = r;
        green_readings_g[i] = g;
        HAL_Delay(50);
    }

    /* Calculate average G/R ratio */
    uint32_t g_r_ratio_sum = 0;
    for (int i = 0; i < 5; i++) {
        if (green_readings_r[i] > 10) { // Avoid division by zero
            g_r_ratio_sum += (green_readings_g[i] * 100) / green_readings_r[i];
        }
    }
    uint16_t avg_g_r_ratio = g_r_ratio_sum / 5;

    /* Set min and max with 10% margin on each side */
    config->green_ratio_min = avg_g_r_ratio * 0.9;
    config->green_ratio_max = avg_g_r_ratio * 1.1;

    sprintf(buffer, "GREEN calibrated: G/R ratio range = %d-%d\r\n",
            config->green_ratio_min, config->green_ratio_max);
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

    /* Mark as calibrated */
    config->is_calibrated = 1;

    sprintf(buffer, "LINE sensor calibration complete!\r\n");
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
    HAL_Delay(1000);
}

/* Calibration function for object sensor */
void TCS3472_CalibrateObjectColors(TCS3472_t *sensor, UART_HandleTypeDef *huart)
{
    char buffer[100];
    uint16_t r, g, b, c;
    ObjectColorConfig_t *config = &sensor->config.object;

    /* Send calibration instructions */
    sprintf(buffer, "Starting OBJECT sensor calibration sequence...\r\n");
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

    /* 1. Calibrate WHITE object */
    sprintf(buffer, "Place OBJECT sensor over WHITE object and press USER button (PA0)...\r\n");
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

    /* Wait for button press */
    //while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET);
    HAL_Delay(5000); // Debounce

    /* Take reading of white object */
    TCS3472_GetRGBC(sensor, &r, &g, &b, &c);
    config->white_threshold = c * 0.8; // 20% margin

    sprintf(buffer, "WHITE calibrated: threshold = %d\r\n", config->white_threshold);
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
    HAL_Delay(1000);

    /* 2. Calibrate RED object */
    sprintf(buffer, "Place OBJECT sensor over RED object and press USER button (PA0)...\r\n");
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

    /* Wait for button press */
    //while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET);
    HAL_Delay(5000); // Debounce

    /* Take reading of red object */
    TCS3472_GetRGBC(sensor, &r, &g, &b, &c);
    uint16_t r_to_g_ratio = (r * 100) / (g > 10 ? g : 10);

    config->red_ratio_min = r_to_g_ratio * 0.8;
    config->red_ratio_max = r_to_g_ratio * 1.2;

    sprintf(buffer, "RED calibrated: R/G ratio range = %d-%d\r\n",
            config->red_ratio_min, config->red_ratio_max);
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
    HAL_Delay(1000);

    /* 3. Calibrate BLUE object */
    sprintf(buffer, "Place OBJECT sensor over BLUE object and press USER button (PA0)...\r\n");
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

    /* Wait for button press */
    //while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET);
    HAL_Delay(5000); // Debounce

    /* Take reading of blue object */
    TCS3472_GetRGBC(sensor, &r, &g, &b, &c);
    uint16_t b_to_g_ratio = (b * 100) / (g > 10 ? g : 10);

    config->blue_ratio_min = b_to_g_ratio * 0.8;
    config->blue_ratio_max = b_to_g_ratio * 1.2;

    sprintf(buffer, "BLUE calibrated: B/G ratio range = %d-%d\r\n",
            config->blue_ratio_min, config->blue_ratio_max);
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
    HAL_Delay(1000);

    /* 4. Calibrate ORANGE-YELLOW object */
    sprintf(buffer, "Place OBJECT sensor over ORANGE-YELLOW object and press USER button (PA0)...\r\n");
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

    /* Wait for button press */
    //while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET);
    HAL_Delay(5000); // Debounce

    /* Take reading of orange-yellow object */
    TCS3472_GetRGBC(sensor, &r, &g, &b, &c);
    uint16_t oy_r_to_g_ratio = (r * 100) / (g > 10 ? g : 10);

    config->orange_yellow_ratio_min = oy_r_to_g_ratio * 0.8;
    config->orange_yellow_ratio_max = oy_r_to_g_ratio * 1.2;

    sprintf(buffer, "ORANGE-YELLOW calibrated: R/G ratio range = %d-%d\r\n",
            config->orange_yellow_ratio_min, config->orange_yellow_ratio_max);
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

    /* Mark as calibrated */
    config->is_calibrated = 1;

    sprintf(buffer, "OBJECT sensor calibration complete!\r\n");
    HAL_UART_Transmit(huart, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
    HAL_Delay(1000);
}

/* Private functions */

/* Write a byte to the TCS3472 register */
static void TCS3472_Write(TCS3472_t *sensor, uint8_t reg, uint8_t value)
{
    uint8_t data[2];
    data[0] = TCS3472_COMMAND_BIT | reg;
    data[1] = value;

    HAL_I2C_Master_Transmit(sensor->hi2c, TCS3472_ADDR, data, 2, 100);
}

/* Read 8-bit value from TCS3472 register */
static uint8_t TCS3472_Read8(TCS3472_t *sensor, uint8_t reg)
{
    uint8_t cmd = TCS3472_COMMAND_BIT | reg;
    uint8_t value;

    HAL_I2C_Master_Transmit(sensor->hi2c, TCS3472_ADDR, &cmd, 1, 100);
    HAL_I2C_Master_Receive(sensor->hi2c, TCS3472_ADDR, &value, 1, 100);

    return value;
}

/* Read 16-bit value from TCS3472 register */
static uint16_t TCS3472_Read16(TCS3472_t *sensor, uint8_t reg)
{
    uint8_t cmd = TCS3472_COMMAND_BIT | reg;
    uint8_t data[2];

    HAL_I2C_Master_Transmit(sensor->hi2c, TCS3472_ADDR, &cmd, 1, 100);
    HAL_I2C_Master_Receive(sensor->hi2c, TCS3472_ADDR, data, 2, 100);

    return (data[1] << 8) | data[0];
}
