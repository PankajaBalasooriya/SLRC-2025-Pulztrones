/**
 ******************************************************************************
 * @file           : sensors.c
 * @brief          : Sensor handling for STM32-based micromouse.
 ******************************************************************************
 */

#include "sensors.h"
#include "raykha.h"
#include "config.h"


extern UART_HandleTypeDef huart6;
/* Variables for steering */
static float m_last_steering_error = 0;
static float m_cross_track_error = 0;
static float m_steering_adjustment = 0;

/* Sensor variables */
volatile SensorChannel lfs, lss, lws, cfs, rss, rfs, rws;  // Front/side/wall sensors
volatile uint8_t see_front_wall = 0;
volatile uint8_t see_left_wall = 0;
volatile uint8_t see_right_wall = 0;
volatile float m_front_sum = 0;
volatile int m_front_diff = 0;
volatile uint8_t g_steering_mode = STEERING_OFF;


// Buffer to store values from all IR channels
uint16_t sensorValues[16] = {0};
uint16_t sensor_values[RAYKHA_NUM_SENSORS];
int32_t line_position;

extern RAYKHA_Calibration raykha_calibration;

JunctionType junction = NO_LINE;


/**
 * Detects junctions during line following
 * @return JunctionType enum value indicating the type of junction detected
 */
JunctionType DetectJunction() {
	int numberOfSensorsOnWhite = 0;

	for(int i = 0; i < RAYKHA_NUM_SENSORS; i++){
		if(sensorValues[i] > LINE_THRESHOLD){
			numberOfSensorsOnWhite++;
		}
	}

	int leftSensorValue = sensorValues[0];
	int rightSensorValue = sensorValues[RAYKHA_NUM_SENSORS - 1];

	if(numberOfSensorsOnWhite > SENSORS_ON_LINE_FOR_JUNCTION_CHECK){
		if (leftSensorValue > LINE_THRESHOLD && rightSensorValue > LINE_THRESHOLD){
			return T_JUNCTION;
		}
		else if (leftSensorValue > LINE_THRESHOLD){
			return LEFT_JUNCTION;
		}
		else if (rightSensorValue > LINE_THRESHOLD){
			return RIGHT_THRESHOLD;
		}
		else{
			return STRAIGHT_LINE;
		}
	}
	else if(numberOfSensorsOnWhite == 0){
		return NO_LINE;
	}


    // Count how many sensors detect a line (high readings)
    int sensorsOnLine = 0;
    int leftSensorsOnLine = 0;
    int rightSensorsOnLine = 0;

    // Assuming sensor_values array holds calibrated readings for all line sensors
    // Typically for line following robots, the array is organized from left to right

    for(int i = 0; i < RAYKHA_NUM_SENSORS; i++) {
    	if(sensor_values[i] > LINE_THRESHOLD) {
			sensorsOnLine++;
    	}
    }

    if(sensorsOnLine >= 1){
    	//junction = LINE;

    	if(sensor_values[0] > LINE_THRESHOLD  && sensor_values[1]){
    		leftSensorsOnLine = 2;
    	}
    	if(sensor_values[RAYKHA_NUM_SENSORS - 1] > LINE_THRESHOLD  && sensor_values[RAYKHA_NUM_SENSORS - 2]){
    		rightSensorsOnLine = 2;
		}

    	if(leftSensorsOnLine == 2 && rightSensorsOnLine == 2){
    		return JUNCTION_T;
    	}
    	else if(leftSensorsOnLine == 2){
    		return JUNCTION_LEFT;
    	}
    	else if(rightSensorsOnLine == 2){
    		return JUNCTION_RIGHT;
    	}
    	else{
    		return LINE;
    	}

    }
    return NO_LINE;
}



// Function to read all channels sequentially
void ReadAllSensors(void)
{
    for (uint8_t i = 0; i < 16; i++)
    {
        sensorValues[i] = AnalogMux_ReadChannel(i);
    }
}

// Function to read a specific set of channels (more efficient)
void ReadSelectedSensors(const uint8_t* channelList, uint8_t numChannels, uint16_t* results)
{
    for (uint8_t i = 0; i < numChannels; i++)
    {
        results[i] = AnalogMux_ReadChannel(channelList[i]);
    }
}



void init_sensor_value(){
	lfs.raw = 0;
	lss.raw = 0;
	lws.raw = 0;
	cfs.raw = 0;
	rss.raw = 0;
	rfs.raw = 0;
	rws.raw = 0;
}


float get_steering_feedback() {
  return m_steering_adjustment;
}
float get_cross_track_error() {
  return m_cross_track_error;
}
uint8_t is_wall_left(){
	return see_left_wall;
}
uint8_t is_wall_right(){
	return see_right_wall;
}
uint8_t is_wall_front(){
	return see_front_wall;
}




/* Calculate steering adjustment */
float CalculateSteeringAdjustment() {
    float pTerm = STEERING_KP * m_cross_track_error;
    float dTerm = STEERING_KD * (m_cross_track_error - m_last_steering_error);
    float adjustment = pTerm + dTerm * LOOP_FREQUENCY;
    adjustment = fminf(fmaxf(adjustment, -STEERING_ADJUST_LIMIT), STEERING_ADJUST_LIMIT);
    m_last_steering_error = m_cross_track_error;
    m_steering_adjustment = adjustment;
    return adjustment;
}

void set_steering_mode(uint8_t mode){
	m_last_steering_error = m_cross_track_error;
	m_steering_adjustment = 0;
	g_steering_mode = mode;
}

void send_sensor_data(){
	char buffer[50];  // Buffer to hold the formatted string

	    // Format the float value into the buffer with the specified decimal points
	    // You can change %.2f to another precision, such as %.3f, %.4f, etc.
	    sprintf(buffer, ">LW:%d,LF:%d,RF:%d,RW:%d\r\n", lws.value, lfs.value, rfs.value, rws.value);  // Use header string as prefix

	    // Transmit the formatted string via UART
	    HAL_UART_Transmit(&huart6, (uint8_t *)buffer, strlen(buffer), HAL_MAX_DELAY);
}


/* Update sensor readings and calculate cross-track error */
void Sensors_Update() {
    // Read ADC values for all sensor channels
	int error = 0;

	if(g_steering_mode == STEERING_CENTER_LINE_FOLLOW){
		RAYKHA_ReadCalibrated(sensor_values, &raykha_calibration);

		/* Get position for PID controller (centered around 0) */
		line_position = RAYKHA_GetPositionForPID(sensor_values, &raykha_calibration);

		error = line_position;

		junction = DetectJunction();
	}

	else if(g_steering_mode == STEER_NORMAL){
		if(lws.raw < 500)lws.raw = 500;
		if(rws.raw < 500)rws.raw = 500;
		if(cfs.raw < 400)cfs.raw = 400;
		//if(lfs.raw > 250)lfs.raw = 250;
		//if(rfs.raw > 230)rfs.raw = 230;

		// Scale sensor values
		//lfs.value = tof_get_distance_mm(lfs.raw, 1);
		//lss.value = tof_get_distance_mm(lss.raw, 0);
		//rss.value = tof_get_distance_mm(rss.raw, 3);
		//rfs.value = tof_get_distance_mm(rfs.raw, 2);
		//lws.value = IR_get_distance_mm(lws.raw, IR_LEFT);
		//rws.value = IR_get_distance_mm(rws.raw, IR_RIGHT);
		//cfs.value = IR_get_distance_mm(cfs.raw, IR_FRONT);

		//UART_Transmit_TOF(&huart6, lfs.value, lws.value, rfs.value, rws.value);

		//UART_Transmit_Int(&huart6, ">L", lws.value);
		//UART_Transmit_Int(&huart6, ">F", cfs.value);
		//UART_Transmit_Int(&huart6, ">R", rws.value);

		// Update wall detection flags

    }
    else if(g_steering_mode == STEERING_FRONT_WALL){


    	if(lfs.raw > 250)lfs.raw = 250;
		if(rfs.raw > 230)rfs.raw = 230;
		if(cfs.raw < 400)cfs.raw = 400;



		error = 0;
    }

//    if (see_front_wall) {
//        error = 0;  // Ignore steering near front walls
//    }

    m_cross_track_error = error;
    CalculateSteeringAdjustment();
    //send_sensor_data();
}


